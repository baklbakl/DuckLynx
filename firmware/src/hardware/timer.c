#include "timer.h"
#include "debugUART.h"
#include "hardware/register.h"
#include "sysctl.h"

const uint32_t REGISTER_SYSCTL_PERIPHCTL_WGPTM_1_INSTANCEMASK = 0b1 << 1;

//1 is up, 0 is down
const uint32_t REGISTER_GPTM_GPTMTnMR_TnCDIR = 0b1 << 4;

const uint32_t REGISTER_GPTM_GPTMTAPR_OFFSET = 0x38;
//Mask for 16 bit prescaler for a wide timer
const uint32_t REGISTER_GPTM_GPTMTAPR_TAPSR_W_MASK = 0xFFFF;

volatile uint32_t * const REGISTER_GPTM_W1_GPTMCFG = (uint32_t *)(REGISTER_GPTM_W1_BASE + REGISTER_GPTM_GPTMCFG_OFFSET);
volatile uint32_t * const REGISTER_GPTM_W1_GPTMTAMR = (uint32_t *)(REGISTER_GPTM_W1_BASE + REGISTER_GPTM_GPTMTAMR_OFFSET);
volatile uint32_t * const REGISTER_GPTM_W1_GPTMCTL = (uint32_t *)(REGISTER_GPTM_W1_BASE + REGISTER_GPTM_GPTMCTL_OFFSET);
volatile uint32_t * const REGISTER_GPTM_W1_GPTMTAILR = (uint32_t *)(REGISTER_GPTM_W1_BASE + REGISTER_GPTM_GPTMTAILR_OFFSET);
volatile uint32_t * const REGISTER_GPTM_W1_GPTMTAPR = (uint32_t *)(REGISTER_GPTM_W1_BASE + REGISTER_GPTM_GPTMTAPR_OFFSET);


int8_t timer_init(void) {
    sysctl_enablePeripheral(REGISTER_SYSCTL_PERIPHCTL_WGPTM_OFFSET, REGISTER_SYSCTL_PERIPHCTL_WGPTM_1_INSTANCEMASK);

    *REGISTER_GPTM_W1_GPTMCTL &= ~REGISTER_GPTM_GPTMCTL_TAEN;
    //Split the two halves of the timer
    *REGISTER_GPTM_W1_GPTMCFG = (*REGISTER_GPTM_W1_GPTMCFG & ~REGISTER_GPTM_GPTMCFG_GPTMCFG_MASK) | REGISTER_GPTM_GPTMCFG_GPTMCFG_SPLIT;
    *REGISTER_GPTM_W1_GPTMTAMR = (*REGISTER_GPTM_W1_GPTMTAMR & ~REGISTER_GPTM_GPTMTnMR_TnMR_MASK) | REGISTER_GPTM_GPTMTnMR_TnMR_ONESHOT; 
    *REGISTER_GPTM_W1_GPTMTAILR = UINT32_MAX - 1;
    *REGISTER_GPTM_W1_GPTMTAPR = (*REGISTER_GPTM_W1_GPTMTAPR & ~REGISTER_GPTM_GPTMTAPR_TAPSR_W_MASK) | (REGISTER_GPTM_GPTMTAPR_TAPSR_W_MASK & UINT16_MAX);

    *REGISTER_GPTM_W1_GPTMCTL |= REGISTER_GPTM_GPTMCTL_TAEN;

    //FIX: Deal with when the timer runs out. (It should take about 38 days). Maybe reset the device?

    return 0;
}
